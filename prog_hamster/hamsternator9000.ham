/*imperative program*/void main() {
	/*
	 * Der Hamster funktioniert aktuell in Relation zu seinem Startfeld (!)
	 * D.h. wenn er auf (3,1) initialisiert wird startet die interne Rechnung
	 * trz. bei (0,0)
	 */

	folgeSpur();
}

/* Richtung muss mit modulo 3 verrechnet werden (durch 3 teilen und Rest ausgeben)
 * 0 = Osten, 1 = Norden, 2 = Westen, 3 = Süden
 * 4 Variablen, daher muss später modulo 4 benutzt werden um Rest 0, 1, 2, 3 zu rechnen.
 */
int richtung = 0;

void updateRichtung() {
	/*
	 * 0 entspricht Osten bzw. nach rechts
	 * 1 entspricht Norden bzw. nach oben
	 * 2 entspricht Westen bzw. nach links
	 * 3 entspricht Süden bzw. nach unten
	 */
	 
	richtung++;
	
	if (richtung > 3) {
		richtung = richtung % 4;
	}
}

// Globale Variablen um Standort zu überprüfen.
int x = 0;
int y = 0;

// Je nachdem in welche Richtung der Hamster blickt wenn er ein Feld
// nach vorne läuft, muss der jeweilge x oder y Wert eins hochzählen.
void updateKoordinaten() {
	// Richtung 0 entspricht Osten, also x+1
	if (richtung == 0) {
		x++;
	}
		
	// Richtung 1 entspricht Norden, also y-1
	else if (richtung == 1) {
		y--;
	}
		
	// Richtung 2 entspricht Westen, also x-1
	else if (richtung == 2) {
		x--;
	}
		
	// Letzter Fall, 3, entspricht Süden, also y+1
	else {
		y++;
	}
}

/* 
 * Hamster soll sich x-mal nach links drehen und aktualisiert bei jeder Drehung seine aktuelle Blickrichtung
 */
void linksUmMitUpdate(int anzahlDrehungen) {
	for(int i = 0; i < anzahlDrehungen; i++) {
		linksUm();
		updateRichtung();
		System.out.println("aktuelle Richtung: " + richtung);
	}
}

/* 
 * Hamster soll x-mal nach vorne laufen und aktualisiert seine Koordinaten hierbei.
 * Dafür wird die Funktion updateKoordinaten() aufgerufen, welche prüft in welche
 * Richtung der Hamster gerade läuft (Blickrichtung)
 */
void vorMitUpdate(int anzahlFelder) {
	for(int i = 0; i < anzahlFelder; i++) {
		vor();
		updateKoordinaten();
	}
}

/*
 * Hamster dreht sich OHNE Aktualisierung der Richtung. Wird nur innerhalb anderer Methoden
 * verwendet, wenn er sich danach wieder in die Ausgangsposition wenden soll.
 */
void rechtsUm() {
	linksUm();
	linksUm();
	linksUm();
}

void kehreUm() {
	linksUm();
	linksUm();
}

boolean linksFrei() {
	// Hamster muss sich nach links drehen um vornFrei() aufrufen zu können
	linksUm();
	
	/* Nach dem Check dreht sich der Hamster wieder zurück
	 * Da return die Funktion beendet, muss sich der Hamster
	 * vorher zurückdrehen
	 */
	 
	if (vornFrei()) {
		rechtsUm();
		
		return true;
	}
	
	// Über else wird false ausgegeben (muss sich ebenfalls zurückdrehen)
	else {
		rechtsUm();
		
		return false;
	}
}

boolean rechtsFrei() {
	// analog zu linksFrei, dreht sich aber nach rechts
	rechtsUm();
	
	if (vornFrei()) {
		linksUm();
		
		return true;
	}
	
	else {
		linksUm();
		
		return false;
	}
}

void nimmGenau(int anzahlKoerner) {
	for(int i = 0; i < anzahlKoerner; i++) {
		nimm();
	}
}

void nimmAlle() {
	// Nimmt solange Körner auf bis das Feld leer ist
	
	while (kornDa()) {
		nimm();
	}
}

void gibGenau(int anzahlKoerner) {
	for(int i = 0; i < anzahlKoerner; i++) {
		gib();
	}
}

void gibAlle() {
	while (maulLeer() != true) {
		gib();
	}
}

void sucheKorn(int anzahlFelder) {
	for(int i = 0; i < anzahlFelder; i++) {
		vor();
		
		// Prüfe ob auf dem neuen Feld ein Korn ist und nehme es auf.
		nimmAlle();
	}
}

void bisZurWand() {
	/* Die untere Funktion bisZurWand(sucheKoerner) wird NUR aufgerufen wenn ein boolean
	 * übergeben wird, ansonsten wird diese Funktion aufgerufen und der Hamster wird weder
	 * suchen noch sammeln.
	 */
	
	while(vornFrei()) {
		vor();
	}
}

void bisZurWand(boolean sucheKoerner) {
	while(vornFrei()) {
		vor();

		/* if (sucheKoerner && kornDa()) {
		 * Da in der eigenen Methode nimmAlle() schon geprüft wird ob ein Korn auf dem Feld liegt
		 * ist der UND Check hier unnötig.
		 */
		
		if(sucheKoerner) {
			nimmAlle();
		}
	}
}

int xRichtung(int xWert) {
	if (xWert < 0) {
		return 2;
	}
	
	else {
		return 0;
	}
}

int yRichtung(int yWert) {
	if (yWert < 0) {
		return 1;
	}
	
	else {
		return 3;
	}
}

void ausrichten(int richtungZiel) {
	/*
	 * Der Hamster soll sich in die Zielrichtung drehen. Bei jeder Drehung zählt
	 * er die Blickrichtung um 1 hoch (linkUmMitUpdate()). Durch den Abgleich mit
	 * der zielRichtung dreht er sich solange bis die beiden Werte gleich sind.
	 */
	
	while (richtungZiel != richtung) {
		linksUmMitUpdate(1);
	}
}

int betrag(int zahl) {
	if (zahl < 0) {
		return zahl * (-1);
	}
	
	else {
		return zahl;
	}
}

void laufeZu(int xZiel, int yZiel) {
	// Wir beginnen mit der x-Richtung
	int xWeg = xZiel - x; // x = aktuelles x, bzw. xStart
	int xBlickrichtung = xRichtung(xWeg);
	
	// Betrag berechnen
	xWeg = betrag(xWeg);
	
	ausrichten(xBlickrichtung);
	vorMitUpdate(xWeg);
	
	// Nun folgt die y-Richtung
	int yWeg = yZiel - y;
	int yBlickrichtung = yRichtung(yWeg);
	
	// Betrag des Weges berechnen
	yWeg = betrag(yWeg);
	
	ausrichten(yBlickrichtung);
	vorMitUpdate(yWeg);
}

boolean vornKornDa() {
	/*
	 * Der Hamster prüft NUR auf seinem aktuellen Feld ob ein Korn vorhanden ist, oder nicht.
	 * Daher muss er erst ein Feld nach vorne gehen und prüft dann, ob ein Korn da ist.
	 
	 * Falls ja:
	 * Bleibe stehen und schließe den Methodenaufruf ab, indem boolean true ausgegeben wird.
	 
	 * Falls nicht:
	 * Kehre zum vorangegangenen Feld zurück. Der Hamster wird sich NICHT in seine vorherige
	 * Blickrichtung drehen! D.h. ist er zum prüfen nach oben, schaut er danach nach unten.
	 * Prüft er das Feld rechts von ihm, schaut er danach nach links.
	 */
	 
	vorMitUpdate(1);
	
	// Korn gefunden! Bleibe stehen, keine weitere Aktion (nimmt nichts auf).
	if (kornDa()) {
		return true;
	}
	
	// Kein Korn gefunden, drehe um und laufe zum Ursprung zurück.
	else {
		linksUmMitUpdate(2);
		vorMitUpdate(1);
		
		return false;
	}
}

boolean sucheKorn() {
	/*
	 * Arbeitet relativ zur Blickrichtung drei angrenzende Felder ab:
	 
	 * Prüfung 1: In Blickrichtung das Feld vor sich prüfen.
	 * Prüfung 2: Nach P1 schaut der Hamster hinter sich, also einmal nach links drehen
	 * 				um zu testen ob das Feld rechts vom Urpsrung ein Korn hat
	 * Prüfung 3: Nach P2 kommt der Hamster vom rechten Feld, schaut also nach links
	 *				keine weitere Richtungsanpassung nötig um das linke Feld zu testen
	 * Prüfung 4: Es wird NICHT davon ausgegangen, dass hinter dem Ursprung ein Korn liegt,
	 				der vollstängiheit halber wird jedoch geprüft. Muss sich nach rechts drehen
	 */
	
	// Prüfung 1: Feld direkt vorne dran
	if (vornKornDa()) {
		return true; // Methode wird beendet falls wahr
	}
	
	// Weiter falls Prüfung 1 nicht wahr gewesen ist
	// Nach Prüfung 1 blickt der Hamster "hinter" sich
	linksUmMitUpdate(1);
	if (vornKornDa()) {
		return true;
	}
	
	// Prüfe das linke Feld (relativ zur ursprünglichen Blickrichtung)
	// Keine Anpassung der Blickrichtung nötig, da nach dem Dreh nach links im Schritt
	// vorher wieder umgekehrt wurde und der Hamster so nach rechts blickt
	
	else if (vornKornDa()) {
		return true;
	}
	
	// Prüfe das hintere Feld (relatif zur ursprünglichen Blickrichtung)
	linksUmMitUpdate(3); // 3x links entspricht 1x rechts
	if (vornKornDa()) {
		return true;
	}
	
	// Kein Feld mit einem Korn gefunden, Hamster bleibt stehen. Durch die vierte Prüfung
	// blickt der Hamster wieder in die ursprüngliche Richtung
	else {
		return false;
	}
}

void folgeSpur() {
	while (sucheKorn()) {
		nimm();
	}
}